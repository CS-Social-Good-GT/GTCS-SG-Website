"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _react = _interopRequireDefault(require("react"));

var _activateOnFocus = _interopRequireDefault(require("part:@sanity/components/utilities/activate-on-focus"));

var _portal = require("part:@sanity/components/utilities/portal");

var _stackedEscapable = _interopRequireDefault(require("part:@sanity/components/utilities/stacked-escapable"));

var _default = _interopRequireDefault(require("part:@sanity/components/buttons/default"));

var _closeIcon = _interopRequireDefault(require("part:@sanity/base/close-icon"));

var _fullscreenIcon = _interopRequireDefault(require("part:@sanity/base/fullscreen-icon"));

var _spinner = _interopRequireDefault(require("part:@sanity/components/loading/spinner"));

var _EditNode = _interopRequireDefault(require("./EditNode"));

var _Editor = _interopRequireDefault(require("./Editor"));

var _Toolbar = _interopRequireDefault(require("./Toolbar/Toolbar"));

var _BlockEditor = _interopRequireDefault(require("./styles/BlockEditor.css"));

var _isMac = _interopRequireDefault(require("./utils/isMac"));

var _getKey = require("./utils/getKey");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// eslint-disable-next-line complexity
function findEditNode(focusPath, editorValue, editor) {
  var focusBlockKey = (0, _getKey.getKey)(focusPath[0]);
  var isVoidRootBlock = focusBlockKey && editorValue && editorValue.document && editorValue.document.size > 0 && editor.query('isVoid', editorValue.document.getDescendant(focusBlockKey));
  var focusInlineKey = !isVoidRootBlock && focusPath[1] && focusPath[1] === 'children' && focusPath[2] && (0, _getKey.getKey)(focusPath[2]);
  var markDefKey = !isVoidRootBlock && focusPath[2] && focusPath[1] === 'markDefs' && (0, _getKey.getKey)(focusPath[2]);
  var key;

  if (markDefKey) {
    var block = editorValue.document.getDescendant(focusBlockKey);

    if (!block) {
      return null;
    }

    var span = block.filterDescendants(desc => desc.type === 'span').find(node => {
      var annotations = node.data.get('annotations') || {};
      return Object.keys(annotations).find(aKey => annotations[aKey] && annotations[aKey]._key === markDefKey);
    });
    return span;
  } else if (focusInlineKey) {
    key = focusInlineKey;
  } else {
    key = focusBlockKey;
  }

  return editorValue.document.getDescendant(key);
}

class BlockEditor extends _react.default.PureComponent {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      preventScroll: false,
      isDragging: false
    });

    _defineProperty(this, "scrollContainer", _react.default.createRef());

    _defineProperty(this, "editor", _react.default.createRef());

    _defineProperty(this, "editorWrapper", _react.default.createRef());

    _defineProperty(this, "checkScrollHeight", () => {
      if (this.scrollContainer && this.scrollContainer.current && this.editorWrapper.current) {
        var preventScroll = this.scrollContainer.current.offsetHeight < this.editorWrapper.current.offsetHeight;

        if (this.state.preventScroll !== preventScroll) {
          this.setState({
            preventScroll
          });
        }
      }
    });

    _defineProperty(this, "handleOnDragEnter", event => {
      this.setState({
        isDragging: true
      });
    });

    _defineProperty(this, "handleOnDragLeave", (0, _debounce2.default)(event => {
      this.setState({
        isDragging: false
      });
    }, 1500));

    _defineProperty(this, "handleToggleFullscreen", event => {
      var onToggleFullScreen = this.props.onToggleFullScreen;
      onToggleFullScreen(event);
    });
  }

  componentDidMount() {
    this.forceUpdate(); // Needed to resolve the refs properly
  }

  componentDidUpdate() {
    this.checkScrollHeight();
  }

  componentWillUnmount() {
    this.handleOnDragLeave.cancel();
  }

  renderNodeEditor() {
    var _this$props = this.props,
        blockContentFeatures = _this$props.blockContentFeatures,
        editorValue = _this$props.editorValue,
        focusPath = _this$props.focusPath;
    var slateNode = findEditNode(focusPath, editorValue, this.getEditor());

    if (!slateNode || slateNode.type === 'contentBlock') {
      return null;
    }

    var value;
    var type;

    if (slateNode.type === 'span') {
      var annotations = slateNode.data.get('annotations');
      var focusedAnnotationName = Object.keys(annotations).find(key => annotations[key]._key === (0, _getKey.getKey)(focusPath[2]));

      if (!focusedAnnotationName) {
        return null;
      }

      value = annotations[focusedAnnotationName];
      type = blockContentFeatures.annotations.find(an => an.value === focusedAnnotationName);

      if (type) {
        return this.renderEditNode(value, type.type, [focusPath[0], 'markDefs', {
          _key: value._key
        }], slateNode);
      }
    }

    value = slateNode.data.get('value');

    var findType = obj => obj.name === value._type;

    if (slateNode.object === 'inline') {
      type = blockContentFeatures.types.inlineObjects.find(findType);

      if (type) {
        return this.renderEditNode(value, type, [focusPath[0], 'children', {
          _key: value._key
        }], slateNode);
      }
    }

    type = blockContentFeatures.types.blockObjects.find(findType);

    if (type) {
      return this.renderEditNode(value, type, [{
        _key: value._key
      }], slateNode);
    }

    return null;
  }

  renderEditNode(nodeValue, type, path, slateNode) {
    var _this$props2 = this.props,
        focusPath = _this$props2.focusPath,
        fullscreen = _this$props2.fullscreen,
        markers = _this$props2.markers,
        onFocus = _this$props2.onFocus,
        onPatch = _this$props2.onPatch,
        readOnly = _this$props2.readOnly,
        value = _this$props2.value;
    return /*#__PURE__*/_react.default.createElement(_EditNode.default, {
      editor: this.getEditor(),
      focusPath: focusPath,
      fullscreen: fullscreen,
      markers: markers,
      nodeValue: nodeValue,
      node: slateNode,
      onFocus: onFocus,
      onPatch: onPatch,
      path: path,
      readOnly: readOnly,
      type: type,
      value: value
    });
  }

  getEditor() {
    if (this.editor && this.editor.current) {
      return this.editor.current.getEditor();
    }

    return null;
  }

  renderEditor() {
    var _this$props3 = this.props,
        blockContentFeatures = _this$props3.blockContentFeatures,
        editorValue = _this$props3.editorValue,
        focusPath = _this$props3.focusPath,
        fullscreen = _this$props3.fullscreen,
        markers = _this$props3.markers,
        onBlur = _this$props3.onBlur,
        onFocus = _this$props3.onFocus,
        onChange = _this$props3.onChange,
        onLoading = _this$props3.onLoading,
        onPatch = _this$props3.onPatch,
        onPaste = _this$props3.onPaste,
        readOnly = _this$props3.readOnly,
        renderBlockActions = _this$props3.renderBlockActions,
        renderCustomMarkers = _this$props3.renderCustomMarkers,
        setFocus = _this$props3.setFocus,
        type = _this$props3.type,
        undoRedoStack = _this$props3.undoRedoStack,
        userIsWritingText = _this$props3.userIsWritingText,
        value = _this$props3.value;
    return /*#__PURE__*/_react.default.createElement(_Editor.default, {
      blockContentFeatures: blockContentFeatures,
      editorValue: editorValue,
      focusPath: focusPath,
      fullscreen: fullscreen,
      markers: markers,
      onBlur: onBlur,
      onChange: onChange,
      onFocus: onFocus,
      onLoading: onLoading,
      onPaste: onPaste,
      onPatch: onPatch,
      onToggleFullScreen: this.handleToggleFullscreen,
      readOnly: readOnly,
      ref: this.editor,
      renderBlockActions: renderBlockActions,
      renderCustomMarkers: renderCustomMarkers,
      scrollContainer: this.scrollContainer,
      setFocus: setFocus,
      type: type,
      undoRedoStack: undoRedoStack,
      userIsWritingText: userIsWritingText,
      value: value
    });
  }

  renderReadOnlyFullscreenButton() {
    var _this$props4 = this.props,
        readOnly = _this$props4.readOnly,
        fullscreen = _this$props4.fullscreen;

    if (!readOnly) {
      return null;
    }

    return /*#__PURE__*/_react.default.createElement("div", {
      className: _BlockEditor.default.readOnlyFullscreenButtonContainer
    }, /*#__PURE__*/_react.default.createElement(_default.default, {
      kind: "simple",
      onClick: this.handleToggleFullscreen,
      title: "Open in fullscreen",
      icon: fullscreen ? _closeIcon.default : _fullscreenIcon.default
    }));
  } // eslint-disable-next-line complexity


  renderBlockEditor() {
    var _this$props5 = this.props,
        blockContentFeatures = _this$props5.blockContentFeatures,
        editorValue = _this$props5.editorValue,
        fullscreen = _this$props5.fullscreen,
        focusPath = _this$props5.focusPath,
        isActive = _this$props5.isActive,
        isLoading = _this$props5.isLoading,
        markers = _this$props5.markers,
        onFocus = _this$props5.onFocus,
        setFocus = _this$props5.setFocus,
        readOnly = _this$props5.readOnly,
        renderBlockActions = _this$props5.renderBlockActions,
        type = _this$props5.type,
        userIsWritingText = _this$props5.userIsWritingText;
    var hasMarkers = markers.filter(marker => marker.path.length > 0).length > 0;
    var isEditingNode = (focusPath || []).length > 1;
    var scrollContainerClassNames = [_BlockEditor.default.scrollContainer, renderBlockActions || hasMarkers ? _BlockEditor.default.hasBlockExtras : null];
    return /*#__PURE__*/_react.default.createElement("div", null, !readOnly && /*#__PURE__*/_react.default.createElement(_Toolbar.default, {
      blockContentFeatures: blockContentFeatures,
      editor: this.getEditor(),
      editorValue: editorValue,
      fullscreen: fullscreen,
      markers: markers,
      onFocus: onFocus,
      onToggleFullScreen: this.handleToggleFullscreen,
      isDragging: this.state.isDragging,
      type: type,
      userIsWritingText: userIsWritingText
    }), isLoading && /*#__PURE__*/_react.default.createElement("div", {
      className: _BlockEditor.default.loading
    }, /*#__PURE__*/_react.default.createElement(_spinner.default, {
      center: true
    })), /*#__PURE__*/_react.default.createElement(_activateOnFocus.default, {
      isActive: !this.state.preventScroll || fullscreen || isActive,
      html: /*#__PURE__*/_react.default.createElement("div", {
        className: _BlockEditor.default.activeOnFocus
      }, /*#__PURE__*/_react.default.createElement("h3", null, "Click to edit"), /*#__PURE__*/_react.default.createElement("div", null, "or"), /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement(_default.default, {
        onClick: this.handleToggleFullscreen,
        color: "primary"
      }, "Open in fullscreen")), /*#__PURE__*/_react.default.createElement("p", {
        className: _BlockEditor.default.keyboardShortcut
      }, "Tip: ", /*#__PURE__*/_react.default.createElement("br", null), /*#__PURE__*/_react.default.createElement("strong", null, _isMac.default ? '⌘' : 'ctrl', "\xA0+\xA0enter"), ' ', "while editing to go in fullscreen")),
      onActivate: setFocus
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: scrollContainerClassNames.join(' '),
      ref: this.scrollContainer
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: _BlockEditor.default.editorWrapper,
      ref: this.editorWrapper
    }, this.renderEditor(), isEditingNode && fullscreen && this.renderNodeEditor()))), isEditingNode && !fullscreen && this.renderNodeEditor());
  }

  render() {
    var _this$props6 = this.props,
        focusPath = _this$props6.focusPath,
        fullscreen = _this$props6.fullscreen,
        readOnly = _this$props6.readOnly;
    var isFocused = (focusPath || []).length;
    return /*#__PURE__*/_react.default.createElement("div", {
      className: _BlockEditor.default.root
    }, fullscreen && /*#__PURE__*/_react.default.createElement(_portal.Portal, null, /*#__PURE__*/_react.default.createElement(_stackedEscapable.default, {
      onEscape: this.handleToggleFullscreen
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: _BlockEditor.default.fullscreen,
      onDragLeave: this.handleOnDragLeave,
      onDragEnter: this.handleOnDragEnter
    }, this.renderReadOnlyFullscreenButton(), this.renderBlockEditor()))), !fullscreen && /*#__PURE__*/_react.default.createElement("div", {
      className: isFocused && !readOnly ? _BlockEditor.default.focus : ''
    }, this.renderReadOnlyFullscreenButton(), this.renderBlockEditor()));
  }

}

exports.default = BlockEditor;

_defineProperty(BlockEditor, "defaultProps", {
  readOnly: false,
  onPaste: undefined,
  renderBlockActions: undefined,
  renderCustomMarkers: undefined
});